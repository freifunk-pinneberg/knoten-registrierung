#!/usr/bin/env php
<?php
declare(strict_types=1);


final class Config
{
    public const DB_PATH = 'database.sqlite';
    #public const PEER_DIR = '/etc/fastd/ffpi/peers';
    public const PEER_DIR = '.';
}


final class Node
{
    public int $id;
    public string $name;
    public string $vpnKey;
    public string $email;
    public ?int $registered;
    public ?int $confirmed;
    public ?int $banned;
    public string $secret;

    public function __construct(array $row)
    {
        $this->id = (int)$row['id'];
        $this->name = $row['name'];
        $this->vpnKey = strtolower($row['vpn_key']);
        $this->email = $row['email'];
        $this->registered = $row['registered'];
        $this->confirmed = $row['confirmed'];
        $this->banned = $row['banned'];
        $this->secret = $row['secret'];
    }

    public function isConfirmed(): bool
    {
        return $this->confirmed !== null;
    }

    public function isBanned(): bool
    {
        return $this->banned !== null;
    }

    public function renderPeerFile(): string
    {
        return implode("\n", [
            '# autogenerated by ' . __FILE__ . ' at ' . time(),
            '# id: ' . $this->id,
            '# name: ' . $this->name,
            '# email: ' . $this->email,
            '# registered: ' . $this->registered,
            '# confirmed: ' . $this->confirmed,
            '# secret: ' . $this->secret,
            '',
            'key "' . $this->vpnKey . '";',
            '',
        ]);
    }
}

final class NodeRepository
{
    private \PDO $pdo;

    public function __construct(string $dbPath)
    {
        $this->pdo = new \PDO('sqlite:' . $dbPath, null, null, [
            \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
            \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
        ]);
    }

    /** @return Node[] */
    public function all(): array
    {
        $rows = $this->pdo->query('SELECT * FROM nodes')->fetchAll();
        return array_map(fn(array $r): Node => new Node($r), $rows);
    }
}

final class PeerStore
{
    private string $dir;
    /** @var array<string,string> vpnKey => file */
    private array $keyToFile = [];

    public function __construct(string $dir)
    {
        $this->dir = rtrim($dir, '/');
        $this->index();
    }

    private function index(): void
    {
        foreach (glob($this->dir . '/*') as $f) {
            if (!is_file($f)) continue;
            if (preg_match('/^\s*key\s+"([0-9a-f]{64})";/mi', file_get_contents($f), $m))
                $this->keyToFile[strtolower($m[1])] = $f;
        }
    }

    private function freeName(string $suggest): string
    {
        $base = preg_replace('/[^A-Za-z0-9_-]+/', '', $suggest) ?: 'node';
        $path = $this->dir . '/' . $base;
        for ($i = 1; is_file($path); $i++)
            $path = $this->dir . '/' . $base . "-$i";
        return $path;
    }

    public function write(Node $n): void
    {
        $file = $this->keyToFile[$n->vpnKey] ?? $this->freeName($n->name);
        if (!is_file($file) || $n->renderPeerFile() !== file_get_contents($file))
            file_put_contents($file, $n->renderPeerFile(), LOCK_EX);
        $this->keyToFile[$n->vpnKey] = $file;
    }

    public function delete(string $vpnKey): void
    {
        if (isset($this->keyToFile[$vpnKey]) && is_file($this->keyToFile[$vpnKey])) {
            @unlink($this->keyToFile[$vpnKey]);
            unset($this->keyToFile[$vpnKey]);
        }
    }
}

final class PeerSynchronizer
{
    private NodeRepository $repo;
    private PeerStore $store;

    public function __construct(NodeRepository $repo, PeerStore $store)
    {
        $this->repo = $repo;
        $this->store = $store;
    }

    public function run(): void
    {
        foreach ($this->repo->all() as $n) {
            if ($n->isBanned()) {
                $this->store->delete($n->vpnKey);
                continue;
            }
            if ($n->isConfirmed()) {
                $this->store->write($n);
            }
        }
    }
}

$sync = new PeerSynchronizer(
    new NodeRepository(Config::DB_PATH),
    new PeerStore(Config::PEER_DIR)
);
$sync->run();
